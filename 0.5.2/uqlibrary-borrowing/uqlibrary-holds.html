<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-signals/core-signals.html">
<link rel="import" href="../uqlibrary-persistent-footer/uqlibrary-persistent-footer.html">

<link rel="import" href="uqlibrary-borrowing-list.html">

<polymer-element name="uqlibrary-holds" attributes="holds" extends="uqlibrary-borrowing-list">

  <template>
    <link rel="stylesheet" href="uqlibrary-borrowing.css">
    <core-signals on-core-signal-transitioning-change="{{transitioningChangeHandler}}"></core-signals>
    <section name="list">
      <uqlibrary-borrowing-list id="holdsTimeline" items="{{holds}}">
      </uqlibrary-borrowing-list>
    </section>
    <uqlibrary-persistent-footer actionButtons="{{actionButtons}}"></uqlibrary-persistent-footer>

  </template>

  <script>
    Polymer('uqlibrary-holds', {

      publish: {
        holds: {
          value : [],
          reflect : true
        }
      },
      transitioning: false,
      actionButtons: [],

      ready: function(){
        this.$.holdsTimeline.noItemsMessage = "No current holds";
        this.actionButtons.push(
          {
            id: 'cancelHolds',
            title: 'Cancel Holds',
            url: 'http://www.library.uq.edu.au'
          }
        );
        this.$.holdsTimeline.showEachDate = true;
        this.$.holdsTimeline.sortByDate = false; // we don't care about placed date, so disable sorting by date
      },

      holdsChanged: function(){
        this.processData();

      },

      processData: function() {
        var _holds = [];

        for (var i = 0; i < this.holds.length; i++) {

          var _hold = this.holds[i];
          _hold.class = 'hold-item';
          _hold.id = i;
          _hold.date = new Date(_hold.datePlaced);
          _hold.dateText = _hold.date.getDate() + '/' + (_hold.date.getMonth() + 1) + '/' + _hold.date.getFullYear();
          _hold.actions = [];

          if(_hold.status == 'bibReady' || _hold.status == 'itemReady') {
            _hold.dayPrefixText = 'Ready';
            _hold.day = 'for';
            _hold.daySuffixText = 'pickup';
            if(_hold.pickupLocation){
              _hold.subtitle = 'Pickup location: ' + _hold.pickupLocation;
            }
          } else if (_hold.status == 'itemTransit') {

            _hold.dayPrefixText = 'Transit';
            _hold.day = 'for';
            _hold.daySuffixText = 'pickup';
            _hold.subtitle = '';
            if(_hold.pickupLocation){
              _hold.secondaryText = 'Pickup location: ' + _hold.pickupLocation;
            }
          }
          else {
            _hold.dayPrefixText = 'On';
            _hold.daySuffixText = 'Hold';
            _hold.day = '';
            _hold.subtitle = 'Date placed: '+ _hold.dateText;
          }
        }

        // Sort by status
        this.holds.sort(function (a, b) {
          var statusOrder = {itemReady: 0, bibReady: 0, itemTransit: 5, onHold: 10};
          if (statusOrder[a.status] > statusOrder[b.status] ) {
            return 1;
          }
          if (statusOrder[b.status] > statusOrder[a.status]) {
            return -1;
          }
          return 0;
        });
      },

      transitioningChangeHandler: function(e) {
        if(e.detail.hasOwnProperty('transitioning'))
          this.transitioning = e.detail.transitioning;
      }

    });

  </script>

</polymer-element>